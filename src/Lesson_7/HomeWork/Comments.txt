Дублирование и неинформативность понятна, отвечать на подобные комментарии смысла нет - переделал.

1) src/Lesson_7/HomeWork/Archer.java
	//вынести одинаковое поведение в абстрактный класс

	Согласен! Так и сделал.
	P.S. Вам задали как-то вопрос по этой задаче(первоначальной - без UI). Можно ли с абстрактным классом - вы сказали, что можно,
	но вы бы сделали без абстрактного класса. Это ваше слова. Препираться не хочу, в любом случае вы правы - с абстрактным классом всё стало
	намного логичнее.
	-----------------------------------------------------------------------
	//нет смысла клонировать примитивы и строки

	Я клонирую объект, а не примитивы. Суть в том, чтобы создать в памяти объект с подобными полями и их значениями,
	но не связанный с оригналом, хотя тут клонирование вообще не нужно.
	---------------------------------------------------------------------------------------------------------------

2) src/Lesson_7/HomeWork/Battle.java
	//операция пишется на отдельной строке от условия

	Вообще, на Хабре, высказывались позволительные формы записи. Запись !!одного!! выражения в одной строке с условным оператором
	выглядит вполне удобно, хотя в "Code Conventions for the Java" фигурные скобки используются всегда и ваше замечание правильное.
	-----------------------------------------------------------------------------------------------------------------------------
	//тут просто A OR B. к чему эти извращения?
	
	Оригинал - (!A ^ !B)
	
	К тому, что если в обоих отрядах есть живые бойцы, то выражение "A OR B" выдаст "true". И это в методе isAnyLoose, где должно
	возвращаться "true" только если в одном из отрядов не осталось живых войнов.
	Можно отрицание тоже убрать - результат останется тот же при XOR`е, но семантика измениться. 
	-----------------------------------------------------------------------------------------------------------------------------
3) src/Lesson_7/HomeWork/Run.java
	//почему все поля и методы статичные?
	
	Изначально такую практику использовал для доступа к данным без создания экземпляра(так проще) - переделал, вся инициализация в отдельном классе,
	вызываются поля через единственный экземпляр класса - одиночку. Run пустой - только для запуска приложения.
	------------------------------------------------------------------------------------------------------------------------------
	//сюда все равно по умолчанию записывается "Название первой команды"

	Верно, но локальные переменные инициализировать обязательно.
	------------------------------------------------------------------------------------------------------------------------------
	//в таком случае якобы остается вариант, когда currentTeam = null. на самом деле такого варианта не должно быть. если не 1, то 2

	Не остаётся - выпадающий список может и будет иметь только два варианта(если брать графический интерфейс) и опять инициализация лок. переменной.
	------------------------------------------------------------------------------------------------------------------------------------------------
	со всеми последующими пунктами этого класса, а так же "src/Lesson_7/HomeWork/Squad.java " согласен - переделал.
	---------------------------------------------------------------------------------------------------------------
4) src/Lesson_7/HomeWork/Squad.java

	Хоть и не нужен этот метод, но его тоже поправил перед удалением.

	@Override
+    protected Squad clone() throws CloneNotSupportedException { //свой код надо проверять перед сдачей
         Squad obj = (Squad)super.clone();
         obj.name = name;
         obj.team = new ArrayList<>();
 
+        for (int i = 0; i < obj.team.size(); i++) { //obj.team.size() равен нулю
+            obj.team.set(i ,team.get(i).clone()); //set в пустой список выдаст ошибку
         }

	   for (Warrior warrior: this.getTeam()) {  // так нужно было.
-            obj.team.add(warrior.clone());	  // P.S. метода getTeam в текущем релизе уже нет
-        }


         return obj;
     }
	
